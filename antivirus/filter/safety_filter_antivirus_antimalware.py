"""
Antivirus/Antimalware Filter for Open WebUI
Scans file uploads with ClamAV for viruses and malware.
version 1.0.0
requirements: clamd, pydantic
"""

from typing import Optional, Callable, Awaitable, List, Any
from pydantic import BaseModel, Field
import datetime
import hashlib
from tempfile import SpooledTemporaryFile
from urllib.parse import urlparse

# Optional third-party imports
try:
    import clamd  # type: ignore
except ImportError:
    clamd = None

# Local Open WebUI imports (guarded for environments outside runtime)
try:
    from open_webui.models.knowledge import Knowledges  # type: ignore
    from open_webui.models.users import Users  # type: ignore
    from open_webui.models.files import Files  # type: ignore
    from open_webui.routers.files import upload_file_handler  # type: ignore
    from open_webui.routers.retrieval import process_file, ProcessFileForm  # type: ignore
    from fastapi import UploadFile  # type: ignore
    from fastapi.concurrency import run_in_threadpool  # type: ignore
except ImportError:  # pragma: no cover - guarded optional runtime deps
    Knowledges = None
    Users = None
    Files = None
    upload_file_handler = None
    process_file = None
    ProcessFileForm = None
    UploadFile = None
    run_in_threadpool = None


class Filter:
    """
    Open WebUI Filter implementation for antivirus/antimalware protection.
    """

    class Valves(BaseModel):
        priority: int = -200
        enabled: bool = True
        scan_attached_files: bool = Field(
            default=True,
            description="Scan files attached to messages with ClamAV.",
        )
        clamav_url: str = Field(
            default="http://localhost:3310",
            description="ClamAV daemon endpoint URL (e.g., 'http://localhost:3310' or 'https://clamav:3310').",
        )
        clamav_timeout: float = Field(
            default=30.0,
            description="ClamAV scan timeout in seconds.",
        )
        block_on_detection: bool = Field(
            default=True,
            description="Block file if malware is detected.",
        )
        delete_infected_files: bool = Field(
            default=False,
            description="Delete infected files from storage (recommended for security).",
        )
        violation_kb: str = Field(
            default="Malware Violations",
            description="Knowledge base name for logging malware detections.",
        )
        max_violations_count: int = Field(
            default=3,
            description="Maximum number of malware violations before user is switched to pending state.",
        )
        enable_full_debug: bool = Field(
            default=False,
            description="Enable heavy debugging logs, including payloads/results (masked & truncated).",
        )
        enable_step_debug: bool = Field(
            default=False,
            description="Enable step-by-step progress logs (concise, truncated).",
        )

    def __init__(self):
        self.valves = self.Valves()

    # Debugging helpers
    def _is_step_debug(self) -> bool:
        return bool(getattr(self.valves, "enable_step_debug", False) or getattr(self.valves, "enable_full_debug", False))

    def _is_full_debug(self) -> bool:
        return bool(getattr(self.valves, "enable_full_debug", False))

    def _truncate(self, text: Any, n: int = 200) -> Any:
        try:
            s = str(text)
        except Exception:
            return text
        if len(s) <= n:
            return s
        return s[: n - 1] + "…"

    def _print_safely(self, *parts: Any) -> None:
        safe_parts: List[Any] = []
        for p in parts:
            if isinstance(p, str):
                p = self._truncate(p)
            safe_parts.append(p)
        try:
            print(*safe_parts)
        except Exception:
            pass

    def _dbg_step(self, *parts: Any) -> None:
        if self._is_step_debug():
            self._print_safely(*parts)

    def _dbg_full(self, *parts: Any) -> None:
        if self._is_full_debug():
            self._print_safely(*parts)

    async def _disable_user(self, user_id: str) -> bool:
        """
        Disable a user account by updating their role to 'pending'.
        """
        self._dbg_step(f"Attempting to disable user {user_id}")
        try:
            if hasattr(Users, "update_user_role_by_id"):
                await run_in_threadpool(Users.update_user_role_by_id, user_id, "pending")
                self._dbg_step(f"User {user_id} disabled via update_user_role_by_id")
                return True
            elif hasattr(Users, "update_user_by_id"):
                await run_in_threadpool(Users.update_user_by_id, user_id, {"role": "pending"})
                self._dbg_step(f"User {user_id} disabled via update_user_by_id")
                return True
            else:
                self._dbg_step("Could not find method to disable user")
                return False
        except Exception as e:
            self._dbg_step(f"Error disabling user: {e}")
            return False

    async def _increment_violation_count(self, user_id: str) -> int:
        """
        Increments the persistent malware violation count for a user.
        Returns the new count.
        """
        if not Users:
            self._dbg_step("Users module not available, cannot persist violation count")
            return 0

        try:
            user = await run_in_threadpool(Users.get_user_by_id, user_id)
            if not user:
                self._dbg_step(f"User {user_id} not found")
                return 0

            current_info = getattr(user, "info", {}) or {}
            if not isinstance(current_info, dict):
                current_info = {}
            
            current_count = current_info.get("malware_violation_count", 0)
            new_count = current_count + 1
            current_info["malware_violation_count"] = new_count
            
            await run_in_threadpool(Users.update_user_by_id, user_id, {"info": current_info})
            self._dbg_step(f"Persisted malware violation count for {user_id}: {new_count}")
            
            return new_count
            
        except Exception as e:
            self._dbg_step(f"Error updating malware violation count for {user_id}: {e}")
            return 0

    async def inlet(
        self,
        body: dict,
        __user__: Optional[dict] = None,
        __event_emitter__: Optional[Callable[[dict], Awaitable[None]]] = None,
        __request__: Optional[Any] = None,
    ) -> dict:
        """
        Filter incoming user messages for malware in attached files.
        """
        self._dbg_full("Inlet called with body:", body)
        if not self.valves.enabled:
            self._dbg_step("Inlet skipped: Disabled")
            return body

        if not self.valves.scan_attached_files:
            self._dbg_step("File scanning disabled")
            return body

        # Store request and user for internal API calls
        self.__request__ = __request__
        self.__user__ = __user__

        messages = body.get("messages", [])
        if not messages:
            self._dbg_step("Inlet skipped: No messages")
            return body

        # Check the last user message
        last_message = messages[-1]
        if last_message.get("role") == "user":
            if __event_emitter__:
                await __event_emitter__({
                    "type": "status",
                    "data": {
                        "description": "Checking for attached files...",
                        "done": False,
                    },
                })
            
            # Files are in metadata, not in the message itself
            files = body.get("metadata", {}).get("files", [])
            if files:
                self._dbg_step(f"Found {len(files)} attached file(s), scanning for malware...")
                if __event_emitter__:
                    await __event_emitter__(
                        {
                            "type": "status",
                            "data": {
                                "description": f"Scanning {len(files)} file(s) for malware...",
                                "done": False,
                            },
                        }
                    )
                
                for idx, file_ref in enumerate(files, 1):
                    if __event_emitter__:
                        await __event_emitter__({
                            "type": "status",
                            "data": {
                                "description": f"Scanning file {idx}/{len(files)}: {file_ref.get('name', 'unknown')}...",
                                "done": False,
                            },
                        })
                    
                    file_is_safe, file_reason, file_hash = await self._scan_file_with_clamav(file_ref, __user__, __event_emitter__)
                    if not file_is_safe and self.valves.block_on_detection:
                        model_name = body.get("model", "unknown")
                        file_name = file_ref.get("name", "unknown")
                        file_id = file_ref.get("id", "unknown")
                        
                        # Delete infected file if configured
                        if self.valves.delete_infected_files:
                            await self._delete_infected_file(file_ref)
                        
                        # Log violation with hash (not actual file)
                        await self.log_violation(__user__, file_name, file_id, file_reason, file_hash, __request__, model_name=model_name)
                        
                        # User lockout logic
                        user_id = __user__.get("id") if __user__ else "unknown"
                        user_role = __user__.get("role") if __user__ else "user"
                        
                        if user_id != "unknown" and user_role != "admin":
                            violation_count = await self._increment_violation_count(user_id)
                            self._dbg_step(f"User {user_id} malware violation count: {violation_count}/{self.valves.max_violations_count}")
                            
                            if violation_count >= self.valves.max_violations_count:
                                self._dbg_step(f"User {user_id} reached max violations. Switching to pending state.")
                                if not await self._disable_user(user_id):
                                    self._dbg_step(f"Failed to switch user {user_id} to pending state")
                        elif user_role == "admin":
                            self._dbg_step(f"Skipping lockout for admin user {user_id}")
                        
                        self._dbg_step(f"Blocking file upload: {file_name} - {file_reason}")
                        if __event_emitter__:
                            await __event_emitter__(
                                {
                                    "type": "status",
                                    "data": {
                                        "description": f"File blocked - malware detected: {file_reason}",
                                        "done": True,
                                    },
                                }
                            )
                        raise ValueError(f"File '{file_name}' blocked - malware detected: {file_reason}")

                # All files clean
                if __event_emitter__:
                    await __event_emitter__({
                        "type": "status",
                        "data": {
                            "description": f"✓ All {len(files)} file(s) scanned - No threats detected",
                            "done": True,
                        },
                    })
            else:
                # No files attached  
                if __event_emitter__:
                    await __event_emitter__({
                        "type": "status",
                        "data": {
                            "description": "No files to scan",
                            "done": True,
                        },
                    })

        return body

    async def log_violation(
        self, user: Optional[dict], file_name: str, file_id: str, reason: str, file_hash: str, request: Optional[Any] = None, model_name: Optional[str] = None
    ) -> None:
        """
        Log malware detection to the configured Knowledge Base.
        """
        self._dbg_step("log_violation called")
        
        # Local logging
        try:
            timestamp = datetime.datetime.now().isoformat()
            record = {
                "user_id": user.get("id", "unknown") if user else "unknown",
                "datetime": timestamp,
                "model": model_name or "unknown",
                "file_name": file_name,
                "file_hash_sha256": file_hash,
                "file_id": file_id,
                "reason": reason,
            }
            self._dbg_full("Malware Violation Record:", record)
        except Exception as e:
            self._dbg_step(f"log_violation local logging error: {e}")

        # Remote KB logging
        if not self.valves.violation_kb or self.valves.violation_kb.lower() == "none":
            self._dbg_step("Violation KB logging disabled (violation_kb not set)")
            return

        if not all([upload_file_handler, process_file, Knowledges, Users, run_in_threadpool]):
            self._dbg_step("Required OpenWebUI modules not available for KB logging")
            return

        if not request or not user:
            self._dbg_step("Missing request or user context for KB logging")
            return

        try:
            user_obj = await run_in_threadpool(Users.get_user_by_id, str(user["id"]))
            if not user_obj:
                self._dbg_step("Could not resolve User object")
                return

            kb_name = self.valves.violation_kb.strip()
            kb_id = None
            
            kbs = await run_in_threadpool(Knowledges.get_knowledge_bases_by_user_id, user_obj.id, "write")
            if kbs:
                for kb in kbs:
                    if kb.id == kb_name or kb.name == kb_name:
                        kb_id = kb.id
                        break
            
            if not kb_id:
                self._dbg_step(f"Violation KB '{kb_name}' not found for user")
                return

            full_log_content = (
                f"--- Malware Detection Report ---\n"
                f"Timestamp: {timestamp}\n"
                f"User ID: {user.get('id', 'unknown')}\n"
                f"User Name: {user.get('name', 'unknown')}\n"
                f"User Email: {user.get('email', 'unknown')}\n"
                f"Model: {model_name or 'unknown'}\n"
                f"File Name: {file_name}\n"
                f"File ID: {file_id}\n"
                f"File Hash (SHA-256): {file_hash}\n"
                f"Threat: {reason}\n"
                f"Note: Actual infected file NOT stored for security reasons.\n"
                f"-------------------------------\n"
            )

            filename = f"malware_detection_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
            
            upload = UploadFile(
                filename=filename,
                file=SpooledTemporaryFile(max_size=1024 * 1024),
                headers={"content-type": "text/plain"},
            )
            upload.file.write(full_log_content.encode("utf-8"))
            upload.file.seek(0)

            try:
                file_data = await run_in_threadpool(
                    upload_file_handler,
                    request,
                    upload,
                    {"source": "antivirus_filter", "type": "malware_report"},
                    False,
                    False,
                    user_obj,
                    None,
                )
            finally:
                await upload.close()

            file_id_uploaded = getattr(file_data, "id", None)
            if file_id_uploaded is None and isinstance(file_data, dict):
                file_id_uploaded = file_data.get("id")
            
            if not file_id_uploaded:
                self._dbg_step("Failed to upload malware report file")
                return

            try:
                await run_in_threadpool(
                    Knowledges.add_file_to_knowledge_by_id,
                    kb_id,
                    file_id_uploaded,
                    user_obj.id,
                )
            except AttributeError:
                knowledge = Knowledges.get_knowledge_by_id(id=kb_id)
                if knowledge:
                    data = getattr(knowledge, "data", None) or {}
                    file_ids = data.get("file_ids", [])
                    if file_id_uploaded not in file_ids:
                        file_ids.append(file_id_uploaded)
                        data["file_ids"] = file_ids
                        Knowledges.update_knowledge_data_by_id(id=kb_id, data=data)

            await run_in_threadpool(
                process_file,
                request,
                ProcessFileForm(file_id=file_id_uploaded, collection_name=kb_id, content=full_log_content),
                user_obj,
            )
            
            self._dbg_step(f"Malware violation logged to KB '{kb_name}' (File ID: {file_id_uploaded})")

        except Exception as e:
            self._dbg_step(f"Error logging malware violation to KB: {e}")

    async def _scan_file_with_clamav(self, file_ref: dict, user: Optional[dict], event_emitter: Optional[Callable] = None) -> tuple[bool, str, str]:
        """
        Scan a file with ClamAV antivirus.
        
        Returns:
            tuple: (is_safe: bool, reason: str, file_hash: str)
        """
        file_id = file_ref.get("id")
        file_name = file_ref.get("name", "unknown")
        
        if not file_id:
            self._dbg_step("File reference missing ID, skipping")
            return True, "", ""
        
        if not clamd:
            self._dbg_step("clamd library not installed, skipping ClamAV scan")
            return True, "", ""
        
        self._dbg_step(f"Scanning file: {file_name} (ID: {file_id})")
        
        try:
            if not Files:
                self._dbg_step("Files module not available")
                return True, "", ""
            
            # Fetch file object
            file_obj = await run_in_threadpool(Files.get_file_by_id, file_id)
            if not file_obj:
                self._dbg_step(f"File {file_id} not found")
                return True, "", ""
            
            # Get file path
            file_path = getattr(file_obj, "path", None)
            if not file_path:
                self._dbg_step("File path not available for ClamAV scan")
                return True, "", ""
            
            # Calculate file hash for forensics
            file_hash = await self._calculate_file_hash(file_path)
            self._dbg_step(f"File hash (SHA-256): {file_hash}")
            
            # Parse host and port from clamav_url
            try:
                parsed = urlparse(self.valves.clamav_url)
                clamav_host = parsed.hostname or parsed.netloc.split(":")[0] if parsed.netloc else "localhost"
                clamav_port = parsed.port or 3310
            except Exception as e:
                self._dbg_step(f"Error parsing clamav_url '{self.valves.clamav_url}': {e}, using defaults")
                clamav_host = "localhost"
                clamav_port = 3310
            
            # Connect to ClamAV daemon
            cd = clamd.ClamdNetworkSocket(
                host=clamav_host,
                port=clamav_port,
                timeout=self.valves.clamav_timeout
            )
            
            # Test connection
            await run_in_threadpool(cd.ping)
            self._dbg_step(f"Connected to ClamAV at {clamav_host}:{clamav_port}")
            
            if event_emitter:
                await event_emitter({
                    "type": "status",
                    "data": {
                        "description": f"Connected to ClamAV - Scanning {file_name}...",
                        "done": False,
                    },
                })
            
            # Scan file by streaming contents (ClamAV in Docker can't access host filesystem)
            self._dbg_step(f"Streaming {file_name} to ClamAV for scanning...")
            
            def _scan_file_stream():
                with open(file_path, "rb") as f:
                    return cd.instream(f)
            
            result = await run_in_threadpool(_scan_file_stream)
            
            # instream returns {"stream": ("FOUND", "virus_name")} or {"stream": ("OK", None)}
            if result and "stream" in result:
                status, virus_name = result["stream"]
                if status == "FOUND":
                    self._dbg_step(f"ClamAV detected: {virus_name}")
                    if event_emitter:
                        await event_emitter({
                            "type": "status",
                            "data": {
                                "description": f"⚠️ Threat detected in {file_name}: {virus_name}",
                                "done": False,
                            },
                        })
                    return False, virus_name, file_hash
                elif status == "OK":
                    self._dbg_step(f"ClamAV scan clean: {file_name}")
                    if event_emitter:
                        await event_emitter({
                            "type": "status",
                            "data": {
                                "description": f"✓ {file_name} - Clean",
                                "done": False,
                            },
                        })
                    return True, "", file_hash
            
            # Unexpected result format
            self._dbg_step(f"Unexpected ClamAV result: {result}")
            return True, "", file_hash
            
        except clamd.ConnectionError as e:
            self._dbg_step(f"ClamAV connection error: {e}")
            # Fail-open: don't block if ClamAV is unavailable
            return True, "", ""
        except Exception as e:
            self._dbg_step(f"ClamAV scan error: {e}")
            # Fail-open: don't block on unexpected errors
            return True, "", ""

    async def _calculate_file_hash(self, file_path: str) -> str:
        """
        Calculate SHA-256 hash of a file for forensic logging.
        """
        try:
            def _hash_file():
                sha256_hash = hashlib.sha256()
                with open(file_path, "rb") as f:
                    for byte_block in iter(lambda: f.read(4096), b""):
                        sha256_hash.update(byte_block)
                return sha256_hash.hexdigest()
            
            file_hash = await run_in_threadpool(_hash_file)
            return file_hash
        except Exception as e:
            self._dbg_step(f"Error calculating file hash: {e}")
            return "HASH_ERROR"

    async def _delete_infected_file(self, file_ref: dict) -> None:
        """
        Delete an infected file from storage.
        """
        file_id = file_ref.get("id")
        file_name = file_ref.get("name", "unknown")
        
        if not file_id or not Files:
            return
        
        try:
            self._dbg_step(f"Deleting infected file: {file_name} (ID: {file_id})")
            
            # Get file object to access path
            file_obj = await run_in_threadpool(Files.get_file_by_id, file_id)
            if file_obj:
                file_path = getattr(file_obj, "path", None)
                if file_path:
                    import os
                    await run_in_threadpool(os.remove, file_path)
                    self._dbg_step(f"File deleted from disk: {file_path}")
                
                # Delete from database
                if hasattr(Files, "delete_file_by_id"):
                    await run_in_threadpool(Files.delete_file_by_id, file_id)
                    self._dbg_step(f"File deleted from database: {file_id}")
        except Exception as e:
            self._dbg_step(f"Error deleting infected file: {e}")
